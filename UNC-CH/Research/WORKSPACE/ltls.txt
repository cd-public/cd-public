property ASSERT_SVA_B10;  // bug is in rf
   @(posedge clk)
(rst || ((~((or1200_rf.rf_we == 1) && (or1200_rf.rf_addrw == 0))) || (or1200_rf.rf_dataw == 0)));
endproperty

SVA_B10 : assert property(ASSERT_SVA_B10);
// psl PSL_B10: assert always (rst || (((or1200_rf.rf_we != 1) || (or1200_rf.rf_addrw != 0)) || (or1200_rf.rf_dataw == 0)))
// @(posedge clk);

// Template:  A until G((B&C)->D)

property ASSERT_SVA_B01;  // also B05, B09, B15
	@(posedge clk)
(rst || (((or1200_ctrl.wb_insn & 'hFFFF0000) >> 16 != 8192) || or1200_except.id_pc != or1200_except.epcr));
endproperty

SVA_B01 : assert property(ASSERT_SVA_B01);
//  l.sys in delay slot will run into infinite loop
//  EPCR on range exception is incorrect
//  EPCR on illegal instruction exception is incorrect
//  Wrong PC stored during FPU exception trap
//  8192 << 16 = "l.sys"
//  English:  "When l.sys is in writeback, the local program counter settings in the exception handler must be equal"

// psl PSL_B01: assert always (rst || (((or1200_ctrl.wb_insn & 'hFFFF0000) >> 16 != 8192) || or1200_except.id_pc != or1200_except.epcr))
// @(posedge clk);

// Template:  A until G(B->C)

property ASSERT_SVA_B03;  
	@(posedge clk)
(rst || ((~((or1200_ctrl.ex_insn & 'hFC0003CF) == 'hE000000D)) || (or1200_rf.rf_dataw == operand_a)));
endproperty

// SVA_B03 : assert property(ASSERT_SVA_B03);
//  l.extw instructions behave incorrectly
//  E000000D = "l.extws"
//  English:  "When l.extws is executing, the data to be written must be equal to the first operand"

// psl PSL_B03: assert always ((rst == 1) || ((~((or1200_ctrl.ex_insn & 'hFC0003CF) == 'hE000000D)) || (or1200_rf.rf_dataw == operand_a)))
// @(posedge clk);

// Template:  A until G(B->C)

property ASSERT_SVA_B04;
	@(posedge clk)
(rst || ((((or1200_ctrl.wb_insn & 'hFFFF0000) >> 16 != 8192)) || (or1200_except.lsu_addr == or1200_except.eear)));
endproperty

SVA_B04 : assert property(ASSERT_SVA_B04);
//  Delay Slot Exception bit is not implemented in SR
//  8192 << 16 = "l.sys"
//  English:  "When l.sys is in writeback, the exception handlers load/save unit address must be the same as EEPROM Address Register"

// psl PSL_B04: assert always (((or1200_ctrl.id_insn & 'hFFFF0000) >> 16 != 8192) || next next (or1200_except.lsu_addr == or1200_except.eear));
// @(posedge clk);

// Template:  A until G(B->C)

property ASSERT_SVA_B06;  
	@(posedge clk)
(rst || ((~((or1200_ctrl.ex_insn & 'hFFE00000) >> 21 == 1826) && (operand_a > operand_b)) || (or1200_sprs.to_sr[9] == 1)));
endproperty

// SVA_B06 : assert property(ASSERT_SVA_B06);
//  Comparison wrong for unsigned inequality with different MSB
//  1826 << 21 = "l.sfgtu" - "(set cbit (gt rA rB))" or "l.mnemonic"
//  English:  "When l.sfgtu, which is some kind of comparison, is executing and the first operand is great than the second, the ninth lowest bit (some flag) of to_sr must be set"

// psl PSL_B06: assert always (rst until ((~((or1200_ctrl.ex_insn & 'hFC0003CF) == 'hE000000D)) || (or1200_rf.rf_dataw == operand_a)))
// @(posedge clk);

// Template:  A until G((B&C)->D)

property ASSERT_SVA_B13;
	@(posedge clk)
(rst || ((~((or1200_ctrl.ex_insn & 'hFC000000) >> 26 == 1) && (or1200_rf.rf_addrw != 9 )) || (or1200_rf.rf_dataw - or1200_except.ex_pc == 8)));
endproperty

// SVA_B13 : assert property(ASSERT_SVA_B13);
//  Call return address failure with large displacement
//  1 << 26 = "l.jal"
//  English:  "When l.jal is executing and the write destination isn't R09, the jump destination less the execution program counter local to the execution handle must be 8 apart"

// psl PSL_B13: assert always (rst until ((~((or1200_ctrl.ex_insn & 'hFC0003CF) == 'hE000000D)) || (or1200_rf.rf_dataw == operand_a)))
// @(posedge clk);

// Template:  A until G((B&C)->D)
