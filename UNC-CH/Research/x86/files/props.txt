INST in [IN, OUT, INS, OUTS] & no exception ->    IOPL >= CPL
SS != old_SS -> SS.RPL == CPL == SS.DPL
DS != old_DS -> DS.DPL >= max(CPL, DS.RPL)
CS != old_CS & (INST is JMP | CALL targets code segment) & CS.C == 0 ->    Target code segment DPL == CPL && RPL in instruction <= CPL
CS != old_CS & (INST is JMP | CALL targets code segment) & CS.C == 1 ->    Target code segment DPL <= CPL
CS != old_CS & INST in [JMP,CALL] & <targeting call-gate> -> CPL <= call gate DPL & RPL in instruction <= call gate DPL
CS != old_CS & INST in [CALL] & <targeting call-gate> & Call-gate points to non-conforming code segment    -> New code segment DPL <= CPL
CS != old_CS & INST in [JMP] & <targeting call-gate> & Call-gate points to non-conforming code segment    -> New code segment DPL == CPL
CS != old_CS & INST in [JMP,CALL] & <targeting call-gate> & Call-gate targets conforming code segment -> New code segment DPL <= CPL
CS != old_CS & INST in [JMP,CALL] & targeting a TSS. // maybe not done
CS != old_CS & INST in [JMP,CALL] & targeting a Task Gate.    // maybe not done
CS != old_CS & INST is far RET -> New CS.DPL >= CPL
Software exception/interrupt raised. -> CPL <= call gate DPL
Software execption/interrupt raised -> New code segment DPL <= CPL
"Instruction is IRET & RFLAGS.NT == 0 & No exception raised -> New CS.DPL >= RPL on stack // RFLAGS.NT is not in nested task
INST not in [JMP, CALL, far RET, SYSCALL, SYSRET, SYSENTER, SYSEXIT, IRET] | exception | interrupt -> CS == old_CS
CS.S == 1 & CS.Type & 0b1000 == 0b1000
SS.S == 1 & SS.Type & 0b1010 == 0b0010
DS.S == 1 & DS.Type & 0b1000 == 0b1000 -> DS.Type & 0b0010 == 0b0010
INST in [VMLAUNCH, VMRESUME] & Does not raise invalid-opcode exception -> RFLAGS.VM == 0 & CS.L == 1 & CS.D == 0
INST in [VMLAUNCH, VMRESUME] & Does not raise #GP -> CPL == 0
INST is VMLAUNCH & Normal exit condition // maybe not done
INST is VMRESUME & Normal exit condition // maybe not done
INST in [POPF, IRET, CPL] -> IOPL_old == IOPL_new
INST in [IRET, POPF, PUSHF, IN, OUT] & IOPL = 3    -> Normal Exit
INST is SYSENTER & 32-bit Protected Mode & No exception raised -> CS.selector == IA32_SYSENTER_CS & EIP == IA32_SYSENTER_EIP & SS == IA32_SYSENTER_CS + 8 & SP == IA32_SYSENTER_ESP
INST is SYSEXIT & 32-bit Protected Mode & No exception raised -> CS.selector == IA32_SYSENTER_CS + 16 & EIP == old_EDX & SS == IA32_SYSENTER_CS + 24 &
SP == old_ECX
INST is SYSENTER & IA-32e Mode & No exception raised -> CS.selector == IA32_SYSENTER_CS & CS.base == 0 & CS.limit == FFFFFFFFH & EIP == IA32_SYSENTER_EIP  & SS.selector == IA32_SYSENTER_CS + 8 & ESP == IA32_SYSENTER_ESP & SS.base == 0 & SS.limit == FFFFFFFFH
INST is SYSEXIT & 64-bit operand size (REX.W used) & IA-32e Mode & No exception raised -> CS.selector == IA32_SYSENTER_CS + 32 & CS.L == 1 & RIP == old_RDX & SS.selector == IA32_SYSENTER_CS + 40 & RSP == old_RCX
INST is SYSEXIT & Non-64-bit operand size (no REX.W) & IA-32e Mode & No exception raised // maybe not done
INST is SYSEXIT & No exception raised -> CPL == 0
// SYSRET and SYSCALL unfinished
INST is WRMSR & No exception raised & Target register in [IA32_SYSENTER_EIP, IA32_SYSENTER_ESP, IA32_LSTAR] ->    Write value was in canonical address form.
// two unfinished
INST in [STI, CLI] & CPL > RFLAGS.IOPL -> RFLAGS.IF == old_RFLAGS.IF & #GP Raised
INST is IRET & CPL > IOPL -> EFLAGS.IF == old_EFLAGS.IF
INST is IRET & CPL != 0 -> EFLAGS.IOPL == old_EFLAGS.IOPL